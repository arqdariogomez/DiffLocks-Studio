# @title 游 DiffLocks Studio - Colab Edition (V68 - Hybrid Stable)
# ==================================================================================
# V68: Basado en Github-Minimal (V52) + Limpieza Profunda + Persistencia en Drive
# - UI estilo Kaggle (checkboxes visibles, dark theme)
# - Limpieza profunda de binarios para evitar errores de NumPy
# - Persistencia de checkpoints en Google Drive (/content/drive/MyDrive/DiffLocks)
# - Aislamiento de procesos con fix para Matplotlib backend
# ==================================================================================

import os
import sys
import time
import shutil
import subprocess
import site
from pathlib import Path

# --- CONFIGURACI칍N ---
REPO_URL = "https://github.com/pinokiofactory/DiffLocks-Studio.git"
REPO_DIR = "/content/DiffLocks-Studio"
DRIVE_PATH = "/content/drive/MyDrive/DiffLocks"
CHECKPOINTS_SUBDIR = "checkpoints/difflocks_diffusion"
MARKER_FILE = "/content/.clean_done"

def log(msg, level="info"):
    colors = {"info": "\033[94m", "success": "\033[92m", "warn": "\033[93m", "err": "\033[91m", "reset": "\033[0m"}
    print(f"{colors.get(level, '')}[{level.upper()}] {msg}{colors['reset']}")

def clean_environment():
    """Limpieza selectiva para evitar conflictos de binarios sin romper el kernel de Colab"""
    if os.path.exists(MARKER_FILE):
        log("Limpieza ya realizada anteriormente.", "info")
        return False

    log("Iniciando limpieza selectiva de entorno (User-site only)...", "warn")
    
    # Paquetes que suelen causar conflictos de binarios (.so)
    bad_pkgs = [
        "numpy", "numpy.libs", "scipy", "scipy.libs", "pandas", "pandas.libs", 
        "matplotlib", "matplotlib.libs", "gradio", "PIL", "cv2", "skimage", "natten",
        "pydantic", "pydantic_core"
    ]
    
    # IMPORTANTE: Solo limpiamos el directorio del USUARIO (~/.local)
    # Limpiar el directorio del sistema (/usr/local) es lo que rompe el kernel de Colab
    user_site = site.getusersitepackages()
    if user_site:
        s_path = Path(user_site)
        if s_path.exists():
            log(f"Limpiando paquetes conflictivos en: {s_path}", "info")
            for pkg in bad_pkgs:
                pkg_path = s_path / pkg
                if pkg_path.exists():
                    shutil.rmtree(pkg_path, ignore_errors=True)
                # Tambi칠n limpiar .dist-info y archivos .so sueltos en user-site
                for dist in s_path.glob(f"{pkg}*"):
                    if dist.is_dir(): shutil.rmtree(dist, ignore_errors=True)
                    else: dist.unlink(missing_ok=True)
    
    # Limpiar carpetas temporales de python
    for tmp in ["/root/.cache/pip", "/root/.cache/matplotlib"]:
        if os.path.exists(tmp): shutil.rmtree(tmp, ignore_errors=True)

    with open(MARKER_FILE, "w") as f: f.write("done")
    log("Limpieza completada. Reiniciando kernel para asegurar entorno limpio...", "success")
    os._exit(0)

def setup_drive():
    """Configura persistencia en Google Drive de forma robusta"""
    if os.path.exists("/content/drive/MyDrive"):
        log("Google Drive ya est치 montado.", "success")
        os.makedirs(DRIVE_PATH, exist_ok=True)
        target_cp = os.path.join(DRIVE_PATH, CHECKPOINTS_SUBDIR)
        os.makedirs(target_cp, exist_ok=True)
        return target_cp

    try:
        from google.colab import drive
        log("Solicitando acceso a Google Drive... (Si la ventana no aparece, usa el icono de carpeta a la izquierda)", "info")
        # Intentamos montaje est치ndar sin force_remount primero, que es m치s estable
        drive.mount('/content/drive')
        
        if os.path.exists("/content/drive/MyDrive"):
            os.makedirs(DRIVE_PATH, exist_ok=True)
            target_cp = os.path.join(DRIVE_PATH, CHECKPOINTS_SUBDIR)
            os.makedirs(target_cp, exist_ok=True)
            return target_cp
    except Exception as e:
        error_msg = str(e)
        if "credential propagation" in error_msg:
            log("丘멆잺 Error de credenciales en Colab. Intenta montarlo manualmente desde el icono de carpeta (izq).", "warn")
        else:
            log(f"No se pudo montar Google Drive ({error_msg}).", "warn")
        
    log("Se usar치 almacenamiento temporal (no persistente) para esta sesi칩n.", "info")
    return None

def install_dependencies():
    log("Instalando dependencias (esto puede tardar unos minutos)...", "info")
    
    # 1. Actualizar pip y herramientas base
    subprocess.run([sys.executable, "-m", "pip", "install", "--upgrade", "pip", "setuptools", "wheel"], check=True)
    
    # 2. Instalar Torch con CUDA espec칤fico (Crucial para Colab)
    log("Instalando PyTorch optimizado para CUDA...", "info")
    subprocess.run([
        sys.executable, "-m", "pip", "install", 
        "torch==2.4.0+cu121", "torchvision==0.19.0+cu121", 
        "--extra-index-url", "https://download.pytorch.org/whl/cu121"
    ], check=True)

    # 3. Instalar requirements.txt omitiendo torch para evitar conflictos
    log("Procesando requirements.txt...", "info")
    try:
        # Usamos --no-deps para los paquetes de requirements y luego resolvemos
        # o simplemente ignoramos los que ya instalamos
        subprocess.run([
            sys.executable, "-m", "pip", "install", 
            "-r", "requirements.txt", 
            "--ignore-installed", "torch", "torchvision"
        ], cwd=REPO_DIR, check=True)
    except Exception as e:
        log(f"Aviso: Fallo parcial en requirements.txt, intentando instalaci칩n forzada de cr칤ticos...", "warn")
        # Si falla el archivo completo, instalamos los m치s importantes manualmente
        criticos = [
            "natten==0.17.1+torch240cu121 --find-links https://shi-labs.com/natten/wheels/",
            "gradio==4.44.1", "pydantic==2.9.2", "moviepy==1.0.3", "einops", "transformers", 
            "accelerate", "safetensors", "scipy", "pandas", "trimesh", "libigl", "mediapipe"
        ]
        for pkg in criticos:
            subprocess.run(f"{sys.executable} -m pip install {pkg}".split(), check=False)

    # 4. Asegurar versiones de UI y parches
    log("Finalizando configuraci칩n de entorno...", "info")
    subprocess.run([sys.executable, "-m", "pip", "install", "gradio==4.44.1", "pydantic==2.9.2", "moviepy==1.0.3"], check=True)

def apply_device_fixes():
    """Aplica parches de c칩digo para compatibilidad de dispositivos"""
    log("Aplicando parches de dispositivo...", "info")
    codec_path = os.path.join(REPO_DIR, "models/strand_codec.py")
    util_path = os.path.join(REPO_DIR, "utils/strand_util.py")
    
    if os.path.exists(codec_path):
        with open(codec_path, 'r') as f: content = f.read()
        content = content.replace("t.to(z.device)", "t.to(z.device) if hasattr(z, 'device') else t")
        with open(codec_path, 'w') as f: f.write(content)
        
    if os.path.exists(util_path):
        with open(util_path, 'r') as f: content = f.read()
        content = content.replace("time_pts.to(device)", "time_pts.to(device) if device else time_pts")
        with open(util_path, 'w') as f: f.write(content)

def run_studio():
    """Lanza la aplicaci칩n en un proceso aislado para evitar conflictos de Matplotlib/Gradio"""
    log("Iniciando DiffLocks Studio...", "success")
    
    # Script lanzador temporal para el proceso aislado
    runner_script = os.path.join(REPO_DIR, "colab_runner.py")
    with open(runner_script, "w") as f:
        f.write("""
import os
import matplotlib
matplotlib.use('Agg', force=True) # Fix para Matplotlib en procesos sin display
import sys
sys.path.append(os.getcwd())
from app import main
if __name__ == "__main__":
    # Forzar modo share de gradio
    import gradio as gr
    def launch_with_share(*args, **kwargs):
        kwargs['share'] = True
        kwargs['server_name'] = '0.0.0.0'
        return original_launch(*args, **kwargs)
    
    # Monkeypatch para asegurar share=True en Colab
    from gradio.blocks import Blocks
    original_launch = Blocks.launch
    Blocks.launch = launch_with_share
    
    main()
""")

    process = subprocess.Popen(
        [sys.executable, runner_script],
        cwd=REPO_DIR,
        stdout=subprocess.PIPE,
        stderr=subprocess.STDOUT,
        text=True,
        bufsize=1
    )

    log("Buscando URL de Gradio...", "info")
    for line in process.stdout:
        print(line, end="")
        if "public URL:" in line:
            url = line.split("public URL:")[1].strip()
            log(f"\n游 ACCESO CONCEDIDO: {url}", "success")
        if "Error" in line or "Exception" in line:
            log(f"Error detectado: {line}", "err")

# --- FLUJO PRINCIPAL ---
try:
    # 1. Limpieza
    clean_environment()
    
    # 2. Setup Drive y Repo
    cp_drive = setup_drive()
    if not os.path.exists(REPO_DIR):
        log(f"Clonando repositorio: {REPO_URL}", "info")
        subprocess.run(["git", "clone", REPO_URL, REPO_DIR])
    
    # 3. Persistencia de Checkpoints (Symlink si Drive est치 disponible)
    local_cp = os.path.join(REPO_DIR, CHECKPOINTS_SUBDIR)
    if cp_drive:
        if os.path.exists(local_cp) and not os.path.islink(local_cp):
            shutil.rmtree(local_cp)
        if not os.path.exists(local_cp):
            os.makedirs(os.path.dirname(local_cp), exist_ok=True)
            os.symlink(cp_drive, local_cp)
            log(f"Persistencia activada: {local_cp} -> {cp_drive}", "success")
    else:
        log("Usando almacenamiento local para checkpoints (no persistente).", "info")
        os.makedirs(local_cp, exist_ok=True)

    # 4. Instalaci칩n y Parches
    install_dependencies()
    apply_device_fixes()
    
    # 5. Ejecuci칩n
    run_studio()

except Exception as e:
    log(f"Error cr칤tico en el lanzador: {str(e)}", "err")
