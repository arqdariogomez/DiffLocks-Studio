# @title üöÄ DiffLocks Studio - Colab Edition (V68 - Hybrid Stable)
# ==================================================================================
# V68: Basado en Github-Minimal (V52) + Limpieza Profunda + Persistencia en Drive
# - UI estilo Kaggle (checkboxes visibles, dark theme)
# - Limpieza profunda de binarios para evitar errores de NumPy
# - Persistencia de checkpoints en Google Drive (/content/drive/MyDrive/DiffLocks)
# - Aislamiento de procesos con fix para Matplotlib backend
# ==================================================================================

import os
import sys
import time
import shutil
import subprocess
import site
import re
import contextlib
import warnings
import logging
from pathlib import Path

# --- SILENCING (Kaggle Style) ---
os.environ['TF_CPP_MIN_LOG_LEVEL'] = '3'
warnings.filterwarnings("ignore")
for name in ["natten", "gradio", "httpx", "uvicorn", "matplotlib", "PIL", "mediapipe"]:
    logging.getLogger(name).setLevel(logging.CRITICAL)

# --- CONFIGURACI√ìN ---
REPO_URL = "https://github.com/arqdariogomez/DiffLocks-Studio.git"
REPO_DIR = "/content/DiffLocks-Studio"
DRIVE_PATH = "/content/drive/MyDrive/DiffLocks"
CHECKPOINTS_SUBDIR = "checkpoints/difflocks_diffusion"
MARKER_FILE = "/content/.clean_done"
HF_WHEELS_REPO = "arqdariogomez/difflocks-env"
WHEELS_DIR = "/content/wheels"

# --- UI DASHBOARD (Kaggle Style) ---
from IPython.display import display, HTML, clear_output

install_log_lines = []

def render_status(progress, message, status="running"):
    colors = {"running": "#818cf8", "success": "#34d399", "error": "#f87171", "warning": "#fbbf24"}
    color = colors.get(status, "#818cf8")
    
    logs_html = ""
    if install_log_lines:
        logs_content = "<br>".join(install_log_lines[-10:])
        logs_html = f"""
        <details style="margin-top: 10px;" open>
            <summary style="cursor: pointer; color: #a1a1aa; font-size: 11px;">üìã √öltimos Logs</summary>
            <div style="background: #18181b; padding: 10px; border-radius: 5px; margin-top: 5px;
                max-height: 150px; overflow-y: auto; font-family: monospace; font-size: 10px; color: #d4d4d8; border: 1px solid #3f3f46;">
                {logs_content}
            </div>
        </details>
        """
    
    html = f"""
    <div style="background: #27272a; border-left: 5px solid {color}; border-radius: 8px; padding: 15px; margin-bottom: 10px; border: 1px solid #3f3f46; font-family: sans-serif;">
        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px;">
            <span style="font-size: 18px; font-weight: 700; color: #fafafa;">üöÄ DiffLocks Studio - Colab Edition</span>
            <span style="background: {color}33; color: {color}; padding: 2px 10px; border-radius: 20px; font-size: 11px; font-weight: 600;">{progress}%</span>
        </div>
        <div style="color: #e4e4e7; font-size: 14px; margin-bottom: 10px;">{message}</div>
        <div style="background: #3f3f46; height: 4px; border-radius: 2px; overflow: hidden;">
            <div style="width: {progress}%; height: 100%; background: {color}; transition: width 0.3s ease;"></div>
        </div>
        {logs_html}
    </div>
    """
    clear_output(wait=True)
    display(HTML(html))

def log(msg, level="info"):
    icons = {"info": "‚ÑπÔ∏è", "success": "‚úÖ", "warn": "‚ö†Ô∏è", "err": "‚ùå"}
    ts = time.strftime('%H:%M:%S')
    line = f"{icons.get(level, '‚ÑπÔ∏è')} [{ts}] {msg}"
    install_log_lines.append(line)
    # Tambi√©n imprimimos en consola por si la UI falla
    print(line)

# --- AUTO-REPAIR (Kaggle Style) ---
def run_cmd(cmd, desc="", cwd=None):
    if desc: render_status(None, desc)
    result = subprocess.run(cmd, shell=isinstance(cmd, str), cwd=cwd, capture_output=True, text=True)
    if result.returncode != 0:
        log(f"Fallo en: {cmd if isinstance(cmd, str) else ' '.join(cmd)}", "err")
        if result.stderr: log(result.stderr[:200], "err")
    return result

def run_cmd_stream(cmd, desc="", cwd=None, progress_val=None):
    """Ejecuta un comando y muestra su salida en tiempo real en los logs de la UI"""
    if desc: render_status(progress_val or 50, desc)
    
    process = subprocess.Popen(
        cmd, 
        shell=isinstance(cmd, str), 
        cwd=cwd, 
        stdout=subprocess.PIPE, 
        stderr=subprocess.STDOUT, 
        text=True,
        bufsize=1
    )
    
    for line in process.stdout:
        line = line.strip()
        if line:
            # Filtrar l√≠neas irrelevantes o muy largas si es necesario
            if len(line) > 150: line = line[:147] + "..."
            log(line, "info")
            if progress_val: render_status(progress_val, desc)
            
    process.wait()
    return process.returncode

def clean_environment():
    """Limpieza selectiva para evitar conflictos de binarios sin romper el kernel de Colab"""
    if os.path.exists(MARKER_FILE):
        log("Limpieza ya realizada anteriormente.", "info")
        return False

    render_status(10, "Iniciando limpieza selectiva de entorno...", "warning")
    
    bad_pkgs = [
        "numpy", "numpy.libs", "scipy", "scipy.libs", "pandas", "pandas.libs", 
        "matplotlib", "matplotlib.libs", "gradio", "PIL", "cv2", "skimage", "natten",
        "pydantic", "pydantic_core"
    ]
    
    user_site = site.getusersitepackages()
    if user_site:
        s_path = Path(user_site)
        if s_path.exists():
            for pkg in bad_pkgs:
                pkg_path = s_path / pkg
                if pkg_path.exists():
                    shutil.rmtree(pkg_path, ignore_errors=True)
                for dist in s_path.glob(f"{pkg}*"):
                    if dist.is_dir(): shutil.rmtree(dist, ignore_errors=True)
                    else: dist.unlink(missing_ok=True)
    
    for tmp in ["/root/.cache/pip", "/root/.cache/matplotlib"]:
        if os.path.exists(tmp): shutil.rmtree(tmp, ignore_errors=True)

    with open(MARKER_FILE, "w") as f: f.write("done")
    render_status(100, "Entorno limpio. REINICIANDO KERNEL...", "success")
    time.sleep(2)
    os._exit(0)

def setup_drive():
    """Configura persistencia en Google Drive de forma robusta"""
    if os.path.exists("/content/drive/MyDrive"):
        log("Google Drive ya est√° montado.", "success")
        os.makedirs(DRIVE_PATH, exist_ok=True)
        target_cp = os.path.join(DRIVE_PATH, CHECKPOINTS_SUBDIR)
        os.makedirs(target_cp, exist_ok=True)
        return target_cp

    try:
        from google.colab import drive
        render_status(20, "Solicitando acceso a Google Drive...", "warning")
        log("Revisa la ventana emergente de Google Drive (o usa el icono de carpeta a la izquierda).", "info")
        drive.mount('/content/drive')
        
        if os.path.exists("/content/drive/MyDrive"):
            os.makedirs(DRIVE_PATH, exist_ok=True)
            target_cp = os.path.join(DRIVE_PATH, CHECKPOINTS_SUBDIR)
            os.makedirs(target_cp, exist_ok=True)
            return target_cp
    except Exception as e:
        error_msg = str(e)
        if "credential propagation" in error_msg:
            log("‚ö†Ô∏è Error de credenciales. Intenta montarlo manualmente desde el icono de carpeta.", "warn")
        else:
            log(f"No se pudo montar Google Drive ({error_msg}).", "warn")
        
    log("Se usar√° almacenamiento temporal para esta sesi√≥n.", "info")
    return None

def install_dependencies():
    render_status(30, "Configurando entorno de dependencias...", "running")
    
    # 1. Intentar descargar Wheels desde HF (Ahorra tiempo de compilaci√≥n)
    # El repo arqdariogomez/difflocks-env es p√∫blico, no requiere token.
    has_local_wheels = False
    render_status(35, "Descargando wheels optimizados desde Hugging Face (Public)...", "running")
    try:
        from huggingface_hub import snapshot_download
        os.makedirs(WHEELS_DIR, exist_ok=True)
        snapshot_download(
            repo_id=HF_WHEELS_REPO,
            repo_type="dataset",
            local_dir=WHEELS_DIR,
            allow_patterns=["wheels/*.whl"]
        )
        if any(Path(WHEELS_DIR).glob("wheels/*.whl")):
            log("Wheels optimizados descargados correctamente (P√∫blico).", "success")
            has_local_wheels = True
    except Exception as e:
        log(f"No se pudieron obtener wheels de HF autom√°ticamente. Se instalar√° normalmente.", "info")

    # 2. Actualizar pip y herramientas base
    run_cmd([sys.executable, "-m", "pip", "install", "--upgrade", "pip", "setuptools", "wheel", "--trusted-host", "pypi.org", "--trusted-host", "files.pythonhosted.org"])
    
    # 3. Instalar Torch con CUDA espec√≠fico
    render_status(40, "Instalando PyTorch (CUDA optimized)...", "running")
    torch_cmd = [
        sys.executable, "-m", "pip", "install", 
        "torch==2.4.0+cu121", "torchvision==0.19.0+cu121", 
        "--extra-index-url", "https://download.pytorch.org/whl/cu121",
        "--trusted-host", "pypi.org", "--trusted-host", "files.pythonhosted.org", "--trusted-host", "download.pytorch.org"
    ]
    if has_local_wheels:
        torch_cmd.extend(["--find-links", os.path.join(WHEELS_DIR, "wheels")])
    run_cmd(torch_cmd)

    # 4. Instalar requirements.txt (Optimizado para Colab)
    render_status(60, "Instalando dependencias del estudio...", "running")
    # Instalamos natten primero
    natten_cmd = [
        sys.executable, "-m", "pip", "install", 
        "natten==0.17.1+torch240cu121", 
        "--find-links", "https://shi-labs.com/natten/wheels/",
        "--trusted-host", "shi-labs.com", "--trusted-host", "pypi.org", "--trusted-host", "files.pythonhosted.org"
    ]
    if has_local_wheels:
        natten_cmd.extend(["--find-links", os.path.join(WHEELS_DIR, "wheels")])
    run_cmd(natten_cmd)
    
    # Instalamos el resto de requirements
    req_cmd = [
        sys.executable, "-m", "pip", "install", 
        "-r", "requirements.txt",
        "--trusted-host", "pypi.org", "--trusted-host", "files.pythonhosted.org", "--trusted-host", "huggingface.co"
    ]
    if has_local_wheels:
        req_cmd.extend(["--find-links", os.path.join(WHEELS_DIR, "wheels")])
    run_cmd(req_cmd, cwd=REPO_DIR)

    # 5. Asegurar versiones cr√≠ticas
    render_status(80, "Finalizando configuraci√≥n...", "running")
    run_cmd([sys.executable, "-m", "pip", "install", "gradio==4.44.1", "pydantic==2.9.2", "moviepy==1.0.3", "huggingface_hub"])


def apply_device_fixes():
    """Aplica parches de c√≥digo para compatibilidad de dispositivos"""
    render_status(85, "Aplicando parches de dispositivo...", "running")
    codec_path = os.path.join(REPO_DIR, "models/strand_codec.py")
    util_path = os.path.join(REPO_DIR, "utils/strand_util.py")
    
    if os.path.exists(codec_path):
        with open(codec_path, 'r') as f: content = f.read()
        content = content.replace("t.to(z.device)", "t.to(z.device) if hasattr(z, 'device') else t")
        with open(codec_path, 'w') as f: f.write(content)
        
    if os.path.exists(util_path):
        with open(util_path, 'r') as f: content = f.read()
        content = content.replace("time_pts.to(device)", "time_pts.to(device) if device else time_pts")
        with open(util_path, 'w') as f: f.write(content)

def run_studio():
    """Lanza la aplicaci√≥n en un proceso aislado"""
    render_status(90, "Iniciando DiffLocks Studio...", "success")
    
    runner_script = os.path.join(REPO_DIR, "colab_runner.py")
    with open(runner_script, "w") as f:
        f.write("""
import os
import matplotlib
matplotlib.use('Agg', force=True)
import sys
sys.path.append(os.getcwd())
from app import main
if __name__ == "__main__":
    import gradio as gr
    from gradio.blocks import Blocks
    original_launch = Blocks.launch
    def launch_with_share(*args, **kwargs):
        kwargs['share'] = True
        kwargs['server_name'] = '0.0.0.0'
        return original_launch(*args, **kwargs)
    Blocks.launch = launch_with_share
    main()
""")

    process = subprocess.Popen(
        [sys.executable, runner_script],
        cwd=REPO_DIR,
        stdout=subprocess.PIPE,
        stderr=subprocess.STDOUT,
        text=True,
        bufsize=1
    )

    log("Buscando URL de Gradio...", "info")
    for line in process.stdout:
        print(line, end="")
        if "public URL:" in line:
            url = line.split("public URL:")[1].strip()
            render_status(100, "üöÄ STUDIO LISTO", "success")
            display(HTML(f'''
                <div style="background: #18181b; border: 2px solid #34d399; border-radius: 12px; padding: 20px; margin-top: 20px; font-family: sans-serif;">
                    <div style="display: flex; align-items: center; gap: 15px; margin-bottom: 15px;">
                        <span style="font-size: 32px;">‚úÖ</span>
                        <span style="font-size: 24px; font-weight: 700; color: #34d399;">¬°DiffLocks Studio en l√≠nea!</span>
                    </div>
                    <div style="background: #27272a; padding: 15px; border-radius: 8px; border: 1px solid #3f3f46;">
                        <p style="color: #a1a1aa; margin: 0 0 10px 0; font-size: 14px;">Accede a trav√©s de esta URL:</p>
                        <a href="{url}" target="_blank" style="color: #818cf8; font-size: 18px; font-weight: 600; text-decoration: none; word-break: break-all;">{url}</a>
                    </div>
                    <p style="color: #71717a; font-size: 12px; margin-top: 15px;">‚ö†Ô∏è Mant√©n esta pesta√±a abierta mientras usas la aplicaci√≥n.</p>
                </div>
            '''))
        if "Error" in line or "Exception" in line:
            log(f"Error detectado: {line}", "err")

# --- FLUJO PRINCIPAL ---
try:
    # 1. Limpieza
    clean_environment()
    
    # 2. Setup Drive y Repo
    cp_drive = setup_drive()
    if not os.path.exists(REPO_DIR):
        render_status(25, "Clonando repositorio...", "running")
        run_cmd(["git", "clone", REPO_URL, REPO_DIR])
    
    # 3. Persistencia de Checkpoints
    local_cp = os.path.join(REPO_DIR, CHECKPOINTS_SUBDIR)
    if cp_drive:
        if os.path.exists(local_cp) and not os.path.islink(local_cp):
            shutil.rmtree(local_cp)
        if not os.path.exists(local_cp):
            os.makedirs(os.path.dirname(local_cp), exist_ok=True)
            os.symlink(cp_drive, local_cp)
            log("Persistencia activada correctamente.", "success")
    else:
        log("Almacenamiento temporal activado.", "info")
        os.makedirs(local_cp, exist_ok=True)

    # 4. Instalaci√≥n y Parches
    install_dependencies()
    
    # Descargar activos y checkpoints usando el script unificado
    log("Verificando credenciales disponibles...", "info")
    if os.environ.get("HF_TOKEN"): log("‚úÖ HF_TOKEN detectado.", "success")
    if os.environ.get("MESH_USER"): log("‚úÖ MESH_USER detectado.", "success")
    
    render_status(82, "Descargando modelos y activos...", "running")
    run_cmd_stream([sys.executable, "download_checkpoints.py"], desc="Descargando modelos y activos...", cwd=REPO_DIR, progress_val=82)
    
    apply_device_fixes()
    
    # 5. Ejecuci√≥n
    run_studio()

except Exception as e:
    render_status(100, f"Error cr√≠tico: {str(e)}", "error")
    log(str(e), "err")
