# @title üöÄ DiffLocks Studio - Colab Edition (V68 - Hybrid Stable)
# ==================================================================================
# V68: Based on Github-Minimal (V52) + Deep Clean + Drive Persistence
# - Kaggle-style UI (visible checkboxes, dark theme)
# - Deep binary cleaning to avoid NumPy/Cuda errors
# - Checkpoint persistence in Google Drive (/content/drive/MyDrive/DiffLocks)
# - Process isolation with Matplotlib backend fix
# ==================================================================================

import os
import sys
import time
import shutil
import subprocess
import site
import re
import contextlib
import warnings
import logging
from pathlib import Path

# --- SILENCING ---
os.environ['TF_CPP_MIN_LOG_LEVEL'] = '3'
warnings.filterwarnings("ignore")
for name in ["natten", "gradio", "httpx", "uvicorn", "matplotlib", "PIL", "mediapipe"]:
    logging.getLogger(name).setLevel(logging.CRITICAL)

# --- CONFIGURATION ---
REPO_URL = "https://github.com/arqdariogomez/DiffLocks-Studio.git"
REPO_DIR = "/content/DiffLocks-Studio"
DRIVE_PATH = "/content/drive/MyDrive/DiffLocks"
CHECKPOINTS_SUBDIR = "checkpoints/difflocks_diffusion"
MARKER_FILE = "/content/.clean_done"
HF_WHEELS_REPO = "arqdariogomez/difflocks-env"
WHEELS_DIR = "/content/wheels"

# --- UI DASHBOARD ---
from IPython.display import display, HTML, clear_output

install_log_lines = []

def render_status(progress, message, status="running"):
    colors = {"running": "#818cf8", "success": "#34d399", "error": "#f87171", "warning": "#fbbf24"}
    color = colors.get(status, "#818cf8")
    
    logs_html = ""
    if install_log_lines:
        logs_content = "<br>".join(install_log_lines[-10:])
        logs_html = f"""
        <details style="margin-top: 10px;" open>
            <summary style="cursor: pointer; color: #a1a1aa; font-size: 11px;">üìã Latest Logs</summary>
            <div style="background: #18181b; padding: 10px; border-radius: 5px; margin-top: 5px;
                max-height: 150px; overflow-y: auto; font-family: monospace; font-size: 10px; color: #d4d4d8; border: 1px solid #3f3f46;">
                {logs_content}
            </div>
        </details>
        """
    
    html = f"""
    <div style="background: #27272a; border-left: 5px solid {color}; border-radius: 8px; padding: 15px; margin-bottom: 10px; border: 1px solid #3f3f46; font-family: sans-serif;">
        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px;">
            <span style="font-size: 18px; font-weight: 700; color: #fafafa;">üöÄ DiffLocks Studio - Colab Edition</span>
            <span style="background: {color}33; color: {color}; padding: 2px 10px; border-radius: 20px; font-size: 11px; font-weight: 600;">{progress}%</span>
        </div>
        <div style="color: #e4e4e7; font-size: 14px; margin-bottom: 10px;">{message}</div>
        <div style="background: #3f3f46; height: 4px; border-radius: 2px; overflow: hidden;">
            <div style="width: {progress}%; height: 100%; background: {color}; transition: width 0.3s ease;"></div>
        </div>
        {logs_html}
    </div>
    """
    clear_output(wait=True)
    display(HTML(html))

def log(msg, level="info"):
    icons = {"info": "‚ÑπÔ∏è", "success": "‚úÖ", "warn": "‚ö†Ô∏è", "err": "‚ùå"}
    ts = time.strftime('%H:%M:%S')
    line = f"{icons.get(level, '‚ÑπÔ∏è')} [{ts}] {msg}"
    install_log_lines.append(line)
    print(line)

# --- AUTO-REPAIR ---
def run_cmd(cmd, desc="", cwd=None):
    if desc: render_status(None, desc)
    result = subprocess.run(cmd, shell=isinstance(cmd, str), cwd=cwd, capture_output=True, text=True)
    if result.returncode != 0:
        log(f"Failed: {cmd if isinstance(cmd, str) else ' '.join(cmd)}", "err")
        if result.stderr: log(result.stderr[:200], "err")
    return result

def run_cmd_stream(cmd, desc="", cwd=None, progress_val=None):
    """Executes a command and shows its output in real-time in the UI logs"""
    if desc: render_status(progress_val or 50, desc)
    
    process = subprocess.Popen(
        cmd, 
        shell=isinstance(cmd, str), 
        cwd=cwd, 
        stdout=subprocess.PIPE, 
        stderr=subprocess.STDOUT, 
        text=True,
        bufsize=1
    )
    
    current_progress = progress_val
    for line in process.stdout:
        line = line.strip()
        if line:
            # Parse progress if present
            if "PROGRESS:" in line:
                try:
                    new_prog = float(line.split("PROGRESS:")[1].strip().replace("%", ""))
                    current_progress = int(new_prog)
                except: pass
            
            if len(line) > 150: line = line[:147] + "..."
            log(line, "info")
            if current_progress: render_status(current_progress, desc)
            
    process.wait()
    return process.returncode

def clean_environment():
    """Selective cleanup to avoid binary conflicts without breaking the Colab kernel"""
    if os.path.exists(MARKER_FILE):
        log("Environment already cleaned.", "info")
        return False

    render_status(10, "Starting selective environment cleanup...", "warning")
    
    bad_pkgs = [
        "numpy", "numpy.libs", "scipy", "scipy.libs", "pandas", "pandas.libs", 
        "matplotlib", "matplotlib.libs", "gradio", "PIL", "cv2", "skimage", "natten",
        "pydantic", "pydantic_core"
    ]
    
    user_site = site.getusersitepackages()
    if user_site:
        s_path = Path(user_site)
        if s_path.exists():
            for pkg in bad_pkgs:
                pkg_path = s_path / pkg
                if pkg_path.exists():
                    shutil.rmtree(pkg_path, ignore_errors=True)
                for dist in s_path.glob(f"{pkg}*"):
                    if dist.is_dir(): shutil.rmtree(dist, ignore_errors=True)
                    else: dist.unlink(missing_ok=True)
    
    for tmp in ["/root/.cache/pip", "/root/.cache/matplotlib"]:
        if os.path.exists(tmp): shutil.rmtree(tmp, ignore_errors=True)

    with open(MARKER_FILE, "w") as f: f.write("done")
    render_status(100, "Environment cleaned. RESTARTING KERNEL...", "success")
    time.sleep(2)
    os._exit(0)

def setup_drive():
    """Configures Google Drive persistence robustly"""
    if os.path.exists("/content/drive/MyDrive"):
        log("Google Drive is already mounted.", "success")
        os.makedirs(DRIVE_PATH, exist_ok=True)
        target_cp = os.path.join(DRIVE_PATH, CHECKPOINTS_SUBDIR)
        os.makedirs(target_cp, exist_ok=True)
        return target_cp

    try:
        from google.colab import drive
        render_status(20, "Requesting Google Drive access...", "warning")
        log("Check the Google Drive popup (or use the folder icon on the left).", "info")
        drive.mount('/content/drive')
        
        if os.path.exists("/content/drive/MyDrive"):
            os.makedirs(DRIVE_PATH, exist_ok=True)
            target_cp = os.path.join(DRIVE_PATH, CHECKPOINTS_SUBDIR)
            os.makedirs(target_cp, exist_ok=True)
            return target_cp
    except Exception as e:
        error_msg = str(e)
        if "credential propagation" in error_msg:
            log("‚ö†Ô∏è Credential error. Try mounting manually from the folder icon.", "warn")
        else:
            log(f"Could not mount Google Drive ({error_msg}).", "warn")
        
    log("Using temporary storage for this session.", "info")
    return None

def install_dependencies():
    render_status(30, "Configuring dependencies environment...", "running")
    
    # 1. Try downloading Wheels from HF (Saves compilation time)
    has_local_wheels = False
    render_status(35, "Downloading optimized wheels from Hugging Face (Public)...", "running")
    try:
        from huggingface_hub import snapshot_download
        os.makedirs(WHEELS_DIR, exist_ok=True)
        snapshot_download(
            repo_id=HF_WHEELS_REPO,
            repo_type="dataset",
            local_dir=WHEELS_DIR,
            allow_patterns=["wheels/*.whl"]
        )
        if any(Path(WHEELS_DIR).glob("wheels/*.whl")):
            log("Optimized wheels downloaded successfully.", "success")
            has_local_wheels = True
    except Exception as e:
        log(f"Could not fetch wheels from HF. Installing normally.", "info")

    # 2. Update pip and base tools
    run_cmd([sys.executable, "-m", "pip", "install", "--upgrade", "pip", "setuptools", "wheel", "--trusted-host", "pypi.org", "--trusted-host", "files.pythonhosted.org"])
    
    # 3. Install Torch with specific CUDA
    render_status(40, "Installing PyTorch (CUDA optimized)...", "running")
    torch_cmd = [
        sys.executable, "-m", "pip", "install", 
        "torch==2.4.0+cu121", "torchvision==0.19.0+cu121", 
        "--extra-index-url", "https://download.pytorch.org/whl/cu121",
        "--trusted-host", "pypi.org", "--trusted-host", "files.pythonhosted.org", "--trusted-host", "download.pytorch.org"
    ]
    if has_local_wheels:
        torch_cmd.extend(["--find-links", os.path.join(WHEELS_DIR, "wheels")])
    run_cmd(torch_cmd)

    # 4. Install requirements.txt (Optimized for Colab)
    render_status(60, "Installing Studio dependencies...", "running")
    natten_cmd = [
        sys.executable, "-m", "pip", "install", 
        "natten==0.17.1+torch240cu121", 
        "--find-links", "https://shi-labs.com/natten/wheels/",
        "--trusted-host", "shi-labs.com", "--trusted-host", "pypi.org", "--trusted-host", "files.pythonhosted.org"
    ]
    if has_local_wheels:
        natten_cmd.extend(["--find-links", os.path.join(WHEELS_DIR, "wheels")])
    run_cmd(natten_cmd)
    
    req_cmd = [
        sys.executable, "-m", "pip", "install", 
        "-r", "requirements.txt",
        "--trusted-host", "pypi.org", "--trusted-host", "files.pythonhosted.org", "--trusted-host", "huggingface.co"
    ]
    if has_local_wheels:
        req_cmd.extend(["--find-links", os.path.join(WHEELS_DIR, "wheels")])
    run_cmd(req_cmd, cwd=REPO_DIR)

    # 5. Ensure critical versions
    render_status(80, "Finalizing configuration...", "running")
    run_cmd([sys.executable, "-m", "pip", "install", "gradio==4.44.1", "pydantic==2.9.2", "moviepy==1.0.3", "huggingface_hub"])


def apply_device_fixes():
    """Applies code patches for device compatibility"""
    render_status(85, "Applying device patches...", "running")
    codec_path = os.path.join(REPO_DIR, "models/strand_codec.py")
    util_path = os.path.join(REPO_DIR, "utils/strand_util.py")
    
    if os.path.exists(codec_path):
        with open(codec_path, 'r') as f: content = f.read()
        content = content.replace("t.to(z.device)", "t.to(z.device) if hasattr(z, 'device') else t")
        with open(codec_path, 'w') as f: f.write(content)
        
    if os.path.exists(util_path):
        with open(util_path, 'r') as f: content = f.read()
        content = content.replace("time_pts.to(device)", "time_pts.to(device) if device else time_pts")
        with open(util_path, 'w') as f: f.write(content)

def run_studio():
    """Launches the application in an isolated process"""
    render_status(90, "Starting DiffLocks Studio...", "success")
    
    runner_script = os.path.join(REPO_DIR, "colab_runner.py")
    with open(runner_script, "w") as f:
        f.write("""
import os
import matplotlib
matplotlib.use('Agg', force=True)
import sys
import threading
import time

# Redirect output to a file for parallel monitoring
log_file = "/content/studio_output.log"
sys.stdout = open(log_file, "w", buffering=1)
sys.stderr = sys.stdout

os.chdir('""" + REPO_DIR + """')
sys.path.append(os.getcwd())

from app import main

if __name__ == "__main__":
    import gradio as gr
    from gradio.blocks import Blocks
    original_launch = Blocks.launch
    def launch_with_share(*args, **kwargs):
        kwargs['share'] = True
        kwargs['server_name'] = '0.0.0.0'
        kwargs['show_error'] = True
        return original_launch(*args, **kwargs)
    Blocks.launch = launch_with_share
    
    main()
""")

    process = subprocess.Popen(
        [sys.executable, runner_script],
        cwd=REPO_DIR,
        stdout=subprocess.PIPE,
        stderr=subprocess.STDOUT,
        text=True,
        bufsize=1
    )

    log("Searching for Gradio URL...", "info")
    
    def monitor_logs():
        log_path = "/content/studio_output.log"
        last_size = 0
        while process.poll() is None:
            if os.path.exists(log_path):
                with open(log_path, "r") as f:
                    f.seek(last_size)
                    new_lines = f.readlines()
                    for line in new_lines:
                        line = line.strip()
                        if line:
                            if any(x in line.lower() for x in ["error", "exception", "failed", "loading", "public url"]):
                                log(f"[Studio] {line}", "info")
                            print(f"[Debug] {line}")
                    last_size = f.tell()
            time.sleep(1)

    import threading
    threading.Thread(target=monitor_logs, daemon=True).start()

    for line in process.stdout:
        print(line, end="")
        
        if "public URL:" in line:
            url = line.split("public URL:")[1].strip()
            render_status(100, "üöÄ STUDIO READY", "success")
            display(HTML(f'''
                <div style="background: #18181b; border: 2px solid #34d399; border-radius: 12px; padding: 20px; margin-top: 20px; font-family: sans-serif;">
                    <div style="display: flex; align-items: center; gap: 15px; margin-bottom: 15px;">
                        <span style="font-size: 32px;">‚úÖ</span>
                        <span style="font-size: 24px; font-weight: 700; color: #34d399;">DiffLocks Studio Online!</span>
                    </div>
                    <div style="background: #27272a; padding: 15px; border-radius: 8px; border: 1px solid #3f3f46;">
                        <p style="color: #a1a1aa; margin: 0 0 10px 0; font-size: 14px;">Access via this URL:</p>
                        <a href="{url}" target="_blank" style="color: #818cf8; font-size: 18px; font-weight: 600; text-decoration: none; word-break: break-all;">{url}</a>
                    </div>
                    <p style="color: #71717a; font-size: 12px; margin-top: 15px;">‚ö†Ô∏è Keep this tab open while using the app.</p>
                </div>
            '''))
        if "Error" in line or "Exception" in line:
            log(f"Error detected: {line}", "err")

# --- MAIN FLOW ---
try:
    # 1. Cleaning
    clean_environment()
    
    # 2. Drive & Repo Setup
    cp_drive = setup_drive()
    if not os.path.exists(REPO_DIR):
        render_status(25, "Cloning repository...", "running")
        run_cmd(["git", "clone", REPO_URL, REPO_DIR])
    
    # 3. Checkpoints Persistence
    local_cp = os.path.join(REPO_DIR, CHECKPOINTS_SUBDIR)
    if cp_drive:
        if os.path.exists(local_cp) and not os.path.islink(local_cp):
            shutil.rmtree(local_cp)
        if not os.path.exists(local_cp):
            os.makedirs(os.path.dirname(local_cp), exist_ok=True)
            os.symlink(cp_drive, local_cp)
            log("Persistence enabled successfully.", "success")
    else:
        log("Temporary storage enabled.", "info")
        os.makedirs(local_cp, exist_ok=True)

    # 4. Installation & Patches
    install_dependencies()
    
    log("Checking available credentials...", "info")
    if os.environ.get("HF_TOKEN"): log("‚úÖ HF_TOKEN detected.", "success")
    if os.environ.get("MESH_USER"): log("‚úÖ MESH_USER detected.", "success")
    
    render_status(82, "Downloading models and assets...", "running")
    run_cmd_stream([sys.executable, "-u", "download_checkpoints.py"], desc="Downloading models and assets...", cwd=REPO_DIR, progress_val=82)
    
    apply_device_fixes()
    
    # 5. Execution
    run_studio()

except Exception as e:
    render_status(100, f"Critical error: {str(e)}", "error")
    log(str(e), "err")
